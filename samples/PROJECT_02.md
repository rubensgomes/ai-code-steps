# usermgr-ms

This project is a cloud native microservice that provides RESTful APIs to manage
the creation of user accounts. It provides APIs to create the user account,
confirm the creation of the user account, change the user's account password,
authenticate the user (e.g., sign in), and display the user account information.

## Overview

This is a Java 21 Spring Boot 3.5.4 microservice application that provides
RESTful APIs to create a user account, confirm the creation of the user account, 
change the user's account password, and authenticate the user. The persistence storage for
the microservice should be implemented in a single table in a MariaDB database.

## API Requirements

The API should be designed to be stateless and should follow RESTful
principles. It should use JSON as the data format for requests and responses.
The API should be secured using JWT (JSON Web Tokens) for authentication and
authorization. The API should also provide proper error handling and return
appropriate HTTP status codes for success and failure scenarios. The API should
be documented using OpenAPI 3.0 specification, and the documentation should be
available in a user-friendly format, such as Swagger UI.

## Set of APIs

### Base URL

http://localhost:8080/api

### API Endpoints

Refer to the [API.md](API.md) file for detailed API documentation.

### Create User Account API

The API to create the user account should provide as inputs a user name, email
and password. It should ensure that the user name and email are unique. Upon
validation the API should store the information provided is stored in a single
table in a MariaDB database. The record created should contain a unique generated
UUID for the user's id or primary key of that table.

The API should also add a time and date timestamp of when the account was
created. This timestamp should be stored in the same table using the UTC
timezone. The API should also generate and store a random token that will be
used to confirm the creation of the user account. This token should be stored in
the same database table along with the user account information. The token
should be a secure random UUID string that is unique for each user account. The
API should return a response with the user account information, including the
user name, email, user ID, and a message advising the user to confirm the
creation of the account in the user's provided email. The response should also
include a status code indicating the success or failure of the operation.

If the user name or email is not unique, the API should return an error
response with a status code indicating the conflict. If the user account is
successfully created, the API should return a status code indicating success
and the user account information in the response body.

It should also send a confirmation email to the user's provided email address
with a link to confirm the creation of the user account. The link should include
the confirmation token generated by the API. The email should contain a message
informing the user that they need to click the link to confirm their account
creation. The email should be sent asynchronously to avoid blocking the API
response. The email should be sent using a reliable email service provider, such
as SendGrid, Amazon SES, or similar. The email should be sent in a background
thread to ensure that the API response is not delayed. The email should be
formatted in HTML and should include a link that the user can click to confirm
their account creation. The link should point to the Confirm User Account
Creation API, which will be described below.

### Confirm User Account Creation API

The API to confirm the creation of the user account should be called by
clicking a link in the previously sent confirmation email. This API should be a
simple GET API that uses the randomly generated token which was placed there by
the previous Create User Account API implementation. The token should be stored
in the database along with the user account information. When the user clicks
the link, the token is validated and the user account is activated. A time stamp
containing the server UTC timezone time and date should be stored in the
database. This allows future tracking of when the account was activated. Also,
once activated a flag should be set in the database to indicate that the user
account is active. The API should return a response indicating the success or
failure of the operation. If the token is valid and the user account
is successfully activated, the API should return a status code indicating
success and a message indicating that the user account has been successfully
confirmed. If the token is invalid or the user account is already confirmed, the
API should return an error response with a status code indicating the conflict
or bad request.

### Request to Change User Account Password API

The API to request a change of the user's account password should provide as
inputs the user's email. The API should validate that the user exists in the
database. If the user exists, the API should generate a secure random token
and send an email to the user's provided email address with a link to change
the user's account password. The link should include the generated token. The
email should contain a message informing the user that they need to click the
link to change their account password. The email should be sent asynchronously
to avoid blocking the API response. The email should be sent using a reliable
email service provider, such as SendGrid, Amazon SES, or similar. The email
should be sent in a background thread to ensure that the API response is not
delayed. The email should be formatted in HTML and should include a link that
the user can click to change their account password. The link should point to
the Change User Account Password API, which will be described below. If the user
does not exist, the API should return an error response with a status code
indicating the not found error. If the user exists, the API should return a
status code indicating success and a message indicating that the password change
request has been successfully sent. The API should also ensure that the user
has not requested a password change in the last 24 hours to prevent abuse.

### Change User Account Password API

The API to change the user's account password should provide as inputs the
user's email, the new password and the token generated in the previous Request
to Change User Account Password API. The API should validate that the user
exists in the database and that the new password meets the required security standards.
It should also validate that the token is valid and has not expired. The token
should be stored in the database along with the user account information. The
API should check that the token is not older than 24 hours. If the token is
valid, the API should update the user's password in the database and return a
response indicating the success or failure of the operation. The API should also
ensure that the new password is different from the old password. If the user
does not exist, the API should return an error response with a status code indicating
the not found error. If the new password does not meet the required security
standards, the API should return an error response with a status code indicating
the bad request error. If the token is invalid or has expired, the API should
return an error response with a status code indicating the unauthorized error.
If the password is successfully changed, the API should return a status code
indicating success and a message indicating that the password has been
successfully changed.

If the user exists, the API should update the user's password in the database
and return a response indicating the success or failure of the operation. The
API should also ensure that the new password is different from the old password.
If the user does not exist, the API should return an error response with a
status code indicating the not found error. If the new password does not meet the
required security standards, the API should return an error response with a
status code indicating the bad request error. If the password is successfully
changed, the API should return a status code indicating success and a message
indicating that the password has been successfully changed.

### Authenticate User API

The API to authenticate the user should provide as inputs the user's email and
password. The API should validate that the user exists in the database and that
the provided password matches the stored password. The API should use a secure
password hashing algorithm, such as bcrypt, to compare the provided password
with the stored password. If the user exists and the password is correct, the
API should generate a JWT token and return it in the response. The JWT token
should include the user's ID, email, and any other relevant information. The
API should also set an expiration time for the token, such as 1 hour. The API
should return a response with the JWT token and a status code indicating the
success or failure of the operation. If the user does not exist, the API should
return an error response with a status code indicating the not found error. If
the password is incorrect, the API should return an error response with a status
code indicating the unauthorized error. If the user is successfully
authenticated, the API should return a status code indicating success and the JWT token in the
response body.

### Display User Account Information API

The API to display the user account information should provide as inputs the
user's email. The API should validate that the user exists in the database. If
the user exists, the API should retrieve the user's account information from the
database and return it in the response. The response should include the user's
ID, name, email, and any other relevant information. The API should return a
response with the user account information and a status code indicating the
success or failure of the operation. If the user does not exist, the API should
return an error response with a status code indicating the not found error. If
the user account information is successfully retrieved, the API should return a
status code indicating success and the user account information in the response
body.

## 🚀 Quick Start

### Prerequisites

- **Java 21** (OpenJDK or Oracle JDK)
- **Docker** and Docker Compose (for local development)
- **Git**

### Local Development

```bash
# Clone the repository
git clone <repository-url>
cd usermgr-ms

# Run the application
./gradlew bootRun

# Run with specific profile
./gradlew bootRun --args='--spring.profiles.active=dev'
```

The application will start on `http://localhost:8080`

### Health Check

```bash
curl http://localhost:8080/actuator/health
```

## 🏗️ Architecture

This microservice follows modern Spring Boot practices with a layered architecture:

```
src/main/java/com/rubensgomes/usermgr/
├── config/          # Configuration classes
├── controller/      # REST controllers
├── service/         # Business logic
├── repository/      # Data access layer
├── model/          # Domain models and DTOs
├── exception/      # Custom exceptions and handlers
└── Application.java # Main application class
```

## 🛠️ Technology Stack

- **Java 21** - Latest LTS version with modern language features
- **Spring Boot 3.4** - Latest stable release
- **Spring Web** - REST API development
- **Spring Data JPA** - Data persistence
- **Spring Actuator** - Production monitoring
- **Spring Validation** - Request validation
- **Gradle Kotlin DSL** - Build automation
- **JUnit 5** - Unit testing
- **Testcontainers** - Integration testing
- **Docker** - Containerization

## 📋 Available Gradle Tasks

```bash
# Build and test
./gradlew build                 # Full build with tests
./gradlew test                  # Run unit tests
./gradlew integrationTest       # Run integration tests
./gradlew check                 # Run all checks (tests, linting)

# Development
./gradlew bootRun              # Run the application
./gradlew bootJar              # Create executable JAR
./gradlew clean                # Clean build artifacts

# Docker
./gradlew bootBuildImage       # Build Docker image using Cloud Native Buildpacks
```

## 🐳 Docker

### Building the Image

```bash
# Using Gradle (recommended)
./gradlew bootBuildImage

# Using Dockerfile
docker build -t usermgr-ms:latest .
```

### Running with Docker

```bash
# Run standalone
docker run -p 8080:8080 usermgr-ms:latest

# Run with Docker Compose
docker-compose up -d
```

## ⚙️ Configuration

The application supports multiple profiles:

- `dev` - Development environment
- `test` - Testing environment  
- `prod` - Production environment

### Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `SERVER_PORT` | Application port | `8080` |
| `SPRING_PROFILES_ACTIVE` | Active Spring profile | `dev` |
| `DATABASE_URL` | Database connection URL | `jdbc:h2:mem:testdb` |
| `DATABASE_USERNAME` | Database username | `sa` |
| `DATABASE_PASSWORD` | Database password | `` |
| `LOG_LEVEL_ROOT` | Root logging level | `INFO` |

### Configuration Files

- `application.yml` - Base configuration
- `application-dev.yml` - Development overrides
- `application-test.yml` - Test overrides
- `application-prod.yml` - Production overrides

## 🧪 Testing

The project includes comprehensive testing:

```bash
# Unit tests
./gradlew test

# Integration tests (with Testcontainers)
./gradlew integrationTest

# All tests
./gradlew check
```

### Test Structure

```
src/test/java/com/rubensgomes/usermgr/
├── unit/           # Unit tests
├── integration/    # Integration tests
└── TestApplication.java
```

## 📊 Monitoring & Observability

Spring Boot Actuator endpoints are available at `/actuator`:

- `/actuator/health` - Application health status
- `/actuator/info` - Application information
- `/actuator/metrics` - Application metrics
- `/actuator/prometheus` - Prometheus metrics (if enabled)

## 🔒 Security

Security considerations implemented:

- Input validation using Bean Validation
- Exception handling with proper error responses
- Actuator endpoints secured appropriately
- CORS configuration for cross-origin requests

## 📝 API Documentation

API documentation is available via:

- **OpenAPI/Swagger UI**: `http://localhost:8080/swagger-ui.html` (when enabled)
- **OpenAPI JSON**: `http://localhost:8080/v3/api-docs`

## 🚀 Deployment

### JAR Deployment

```bash
# Build executable JAR
./gradlew bootJar

# Run the JAR
java -jar build/libs/usermgr-ms-*.jar
```

### Docker Deployment

```bash
# Build and run with Docker Compose
docker-compose up -d --build

# Scale the service
docker-compose up -d --scale app=3
```

### Cloud Deployment

The application is cloud-ready and supports:

- **Kubernetes** - Deployment manifests in `/k8s`
- **Cloud Foundry** - Ready for `cf push`
- **Heroku** - Procfile included
- **AWS/GCP/Azure** - Container registry compatible

## 🔧 Development Guidelines

### Code Style

- Follow standard Java naming conventions
- Use Spring Boot best practices
- Implement proper exception handling
- Write meaningful tests with good coverage

### Git Workflow

```bash
# Feature development
git checkout -b feature/new-feature
git commit -m "feat: add new feature"
git push origin feature/new-feature
```

### Commit Messages

Follow conventional commits format:
- `feat:` - New features
- `fix:` - Bug fixes
- `docs:` - Documentation changes
- `refactor:` - Code refactoring
- `test:` - Test additions/modifications

## 📚 Useful Resources

- [Spring Boot Documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/)
- [Java 21 Features](https://openjdk.org/projects/jdk/21/)
- [Gradle Kotlin DSL](https://docs.gradle.org/current/userguide/kotlin_dsl.html)
- [Docker Best Practices](https://docs.docker.com/develop/dev-best-practices/)

## 🤝 Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Ensure all tests pass
6. Submit a pull request

## 📄 License

This project is licensed under the [MIT License](LICENSE).

---

**Note**: Replace `usermgr-ms` and `com/rubensgomes/usermgr` with actual values during project initialization.
